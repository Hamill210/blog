---
title: "루비 && 1일: 유모찾기"
category: "Ruby"
date: "2021-09-07"
desc: "브루스 테이트의 세븐 랭귀지를 정리했습니다"
thumbnail: "./images/default.jpg"
alt: "브루스 테이트의 세븐 랭귀지 책을 읽으며 1장 1일차에 대한 학습을 정리했습니다"
---

새로운 언어를 배운다는 건 새로운 사람을 만나는 것과 비슷하고, 그런 언어들은 사람처럼 저마다의 성격을 가지고 있다. 이 책에서 소개하는 7가지의 언어를 유명한 사람에 빗대어 설명하여, 각각의 언어가 가지고 있는 고유한 성격을 드러내려고 노력할 것이다.

루비는 메리포핀스를 생각하면 좋다. 메리 포핀스는 모든 것을 재미있는 놀이로 만들었고, 자신의 매력에서 발산되는 열정으로 아이들을 설득함으로써 집안 분위기를 효율적으로 만들었다. 루비는 한 숟갈보다 더 많은 문법적 설탕으로 메리 포핀스와 같은 일을 했다. 루비는 언어의 효율성보다 프로그래머의 효율성을 최적화하는 데 집중한다.

※ 문법적 설탕 : 똑같은 코드를 다르게 표현함으로써 코드를 읽거나 쓰는 것을 더 쉽게 만들어주는 언어적 특징을 의미

## 루비에 대하여

마츠모토 유키히로는 1993년에 루비를 만들었다. 그리고 2006년 무렵 레일스 프레임워크와 함께 폭발적으로 부상했다.

루비는 인터프리트되고, 객체지향적이며, 동적 타이핑 시스템을 이용하는 스크립트 언어이다. 인터프리트된다는 말은 루비가 컴파일러가 아닌 인터프리터에 의해 실행된다는 뜻이다. 동적 타이핑을 사용한다는 말은 자료형이 컴파일 시간이 아니라 실행 시간에 결정된다는 의미이다. 이 두 가지 방식은 유연성을 위해 안전성을 포기한 트레이드 오프라고 할 수 있다. 객체지향이라는 말은 언어가 캡슐화, 클래스를 통한 상속, 다형성을 지원한다는 뜻이다.

루비는 실행 속도라는 측면에서 보면 그렇게 효율적이지는 않지만, 프로그래머 자체를 매우 생산적으로 만든다.

마츠가 택한 트레이드 오프에 관심을 기울여보자. 프로그래머에게 조금 더 친숙한 경험을 제공하기 위해, 그리고 코드를 조금 더 쉽게 이해할 수 있도록 만들기 위해 기본적인 규칙을 위반하는 작은 기능들, 즉 문법적 설탕에 대해 주의를 기울여보자. 그리고 컬렉션이나 그 밖의 다른 곳에서 놀라운 효능을 보여주는 마츠의 코드를 찾아내기 바란다. 그리하여 그가 단순함과 안전성 사이에서, 그리고 생산성과 성능 사이에서 어떤 트레이드 오프를 선택했는지 이해하려 시도해보자. (단순함 > 안전성, 생산성 > 성능 - 마츠가 선택한 트레이드 오프)

## 1일: 유모 찾기

어떤 언어를 처음으로 배울 때 가장 먼저 해봐야 하는 일은 해당 언어로 이미 할 줄 아는 일들을 해보는 것이다. 루비를 처음으로 이용하는 경험을 하나의 대화라고 생각해보자. 그 대화가 자연스럽게 흘러가는가 아니면 불필요하게 막히는가? 핵심적인 프로그래밍 모델은 무엇인가? 자료형을 어떻게 다루는가? 이런 질문에 답을 구해보자.

```ruby
>> puts 'hello, world'
hello, world
=> nil
>> language = 'Ruby'
=> "Ruby"
>> puts "hello, #{language}"
hello, Ruby
=> nil
>> language = 'my Ruby'
=> "my Ruby"
>> puts "hello, #{language}"
hello, my Ruby
=> nil
```

이 짧은 예에서 루비라는 언어에 대해 많은 것을 알 수 있다. 루비는 거의 언제나 인터프리트 된다. 그리고 모든 명령은 언제나 어떤 값을 리턴한다. 그리고 최소 두 가지 종류의 문자열을 확인 할 수 있다. 작은따옴표에 둘러싸인 문자열은 문자열 그 자체를 구성한다는 뜻이고, 큰따옴표에 둘러싸인 문자열은 그 안에 담긴 내용을 평가한다. 루비 인터프리터가 평가하는 내용 중 하나는 문자열 치환이다.

### 프로그래밍 모델

어떤 프로그래밍 언어에 대한 질문 중 맨 처음 대답해야 하는 질문은 '프로그래밍 모델이 무엇인가요?' 라는 질문이다. 간단한 질문은 아니다. 당신은 지금까지 C, 포트란, 혹은 파스칼 같은 절차적 언어들을 경험해왔을 것이다. 오늘날 우리는 객체지향 언어를 사용하고 있지만, 그런 언어에는 절차적 언어의 속성이 다분히 포함되어 있다. 예를 들어 자바에서 4는 객체가 아니다. 스칼라 같은 언어는 함수 언어지만 그 안에 객체지향이란 개념을 섞었다. 포스트스크립트나 포스(Forth) 같은 스택 기반 언어는 언어의 핵심적인 기능으로 하나 이상의 스택을 사용한다. 프롤로그 같은 논리기반 언어는 규칙을 중심으로 구성되고, Io, 루아, 셀프와 같은 프로토타입 언어는 객체를 정의하기 위한 기반 혹은 상속도 클래스가 아닌 객체를 사용한다.

루비는 순수한 객체지향 언어다. 이 장에서 우리는 루비가 그러한 개념을 얼마나 철저하게 구현했는지 보게 될 것이다.

```ruby
>> 4
=> 4
>> 4.class
=> Integer
>> 4 + 4
=> 8
>> 4.methods
=> [=> [:-@, :**, :<=>, :upto, :<<, :<=, :>=, :==,
 :chr, :===, :>>, :[], :%, :&, :inspect, ...
]
```

루비에서는 개별적인 숫자를 포함한 거의 모든 것이 객체다. 숫자는 Integer 라는 클래스를 사용하는 객체다. 그리고 methods 라는 이름의 메서드를 호출하면 그 객체가 가지고 있는 메서드의 배열이 리턴된다(루비는 대괄호를 이용해 배열을 표시한다). 사실 점만 찍으면 어떤 메서드라도 맘껏 호출할 수 있다.

### 결정

프로그램은 어떤 결정을 내리기 위해 존재한다. 따라서 어떤 언어가 결정을 내리는 과정은 당신이 코딩하고 생각하는 방식에 결정적인 영향을 끼친다. 이런 면에서 루비는 대부분의 객체지향 언어나 혹은 절차적 언어와 별로 다르지 않다.

```ruby
>> x = 4
=> 4
>> x < 5
=> true
>> x <= 4
=> true
>> x > 4
=> false
>> false.class
=> FalseClass
>> true.class
=> TrueClass
```

루비는 true 또는 false 라는 값으로 평가되는 표현을 가지고 있다. 여기에서 true와 false는 그 자체로 일급 객체에 해당한다. 이들을 이용하면 어떤 코드를 조건에 따라서 실행할 수 있다.

```ruby
>> x = 4
=> 4
>> puts 'This appears to be false.' unless x == 4
=> nil
>> puts 'This appears to be true.' if x == 4
This appears to be true.
=> nil
>> if x == 4
>>   puts 'This appears to be true.'
>> end
This appears to be true.
=> nil
>> unless x == 4
>>. puts 'This appears to be false.'
>> else
>>  puts 'This appears to be true.'
>> end
This appears to be true.
=> nil
>> puts 'This appears to be true.' if not true
=> nil
>> puts 'This appears to be true.' if !true
=> nil
```

조건 분기를 간단하게 만든 루비의 설계가 참 마음에 든다. if 혹은 unless를 사용할 때 원한다면 블록 형태를 사용할 수도 있고(if 조건문, 명령문, end), 한 줄 짜리 형태를 사용할 수도 있다(명령문 if 조건문). 어떤 사람은 한 줄 짜리 if 문법을 좋지않게 생각하지만, 한 가지 생각을 한 줄에 담을 수 있는 고마운 기능이라 생각한다.

while과 until도 비슷하다.

```ruby
>> x = x + 1 while x < 10
>= nil
>> x
=> 10
>> x = x - 1 until x == 1
=> nil
>> x
=> 1
>> while x < 10
>>   x = x + 1
>>.  puts x
>> end
2
3
4
5
6
7
8
9
10
=> nil
```

= 은 할당이고, == 은 동일 여부 검사하는 연산이다. 루비에서는 각각의 객체가 동일성을 규정하는 논리를 포함한다. 숫자의 경우 수의 값 자체가 같으면 서로 동일하다.

true와 false 대신 값을 사용하는 것도 가능하다.

```ruby
>> puts 'This appears to be true.' if 1
This appears to be true.
=> nil
>> puts 'This appears to be true.' if 'random string'
(irb):31: warning: string literal in condition
This appears to be true.
=> nil
>> puts 'This appears to be true.' if 0
This appears to be true.
=> nil
>> puts 'This appears to be true.' if true
This appears to be true.
=> nil
>> puts 'This appears to be true.' if false
This appears to be true.
=> nil
puts 'This appears to be true.' if nil
=> nil
```

nil과 false를 제외한 모든 것은 true로 평가된다. 0조차 true가 된다는 사실을 기억하자.

논리적 연산자는 and(혹은 &&)는 논리적 and를 의미한다. or(혹은 ||)는 논리적 or다. 이런 연산자로 계산할 때, 인터프리터는 계산 결과가 명확하게 결정될 때까지만 계산을 수행한다. 표현 전체를 계산하고 싶으면 & 혹은 | 연산자를 사용하라.

```ruby
>> true and false
=> false
>> true or false
=> true
>> false && false
=> false

>> true && this_will_cause_an_error
NameError: undefined local variable or method 'this_will_cause_an_error'
>> false && this_will_cause_an_error
=> false
>> true or this_will_cause_an_error
=> true
>> true || this_will_cause_an_error
=> true
>> true | this_will_cause_an_error
NameError: undefined local variable or method 'this_will_cause_an_error'
>> true | false
=> true
```

실제 프로그래밍에서는 결과가 나오면 테스트를 중단하는 단축평가(short-circuit) 연산자(&&나 ||)를 사용하는 것이 보통이다.

### 오리 타이핑(덕 타이핑)

루비의 타이핑 모델에 대해 살펴보자. 우리가 자료형과 관련해서 실수를 저질렀을 때 루비가 우리를 얼마나 보호해줄까? 즉, 형 안전성에 대해 이야기하는 것이다.

강한 타이핑을 사용하는 언어는 특정 연산이 일어날 때 그러한 연산이 어떤 오류를 만들어내기 전에 자료형을 검사한다. 이런 검사는 인터프리터에서, 혹은 컴파일러에서, 혹은 실행 시간에 일어날 수 있다.

```ruby
>> 4 + 'four'
TypeError: String can't be coerced into Integer
>> 4.class
=> Integer
>> (4.0).class
=> Float
>> 4 + 4.0
=> 8.0
```

이처럼 루비는 강한 타이핑을 사용한다(강타입 시스템을 사용하는 언어가 아니지만, 강타입 시스템을 이용하는 언어처럼 동작한다). 즉 자료형이 서로 충돌을 일으키면 에러가 발생한다. 루비는 이와 같은 형 검사를 컴파일이 아니라 실행 시간에 수행한다. 이를 증명하기 위해, 함수를 일반적인 경우보다 미리 정의하는 방법이 있다. def라는 키워드는 함수를 정의하지만 실행하지 않는다.

```ruby
>> def add_them_up
>>      4 + 'four'
>> end
=> nil
>> add_them_up
TypeError: String can't be coerced info Integer
```

결국 루비는 어떤 코드를 실제로 실행하기 전까지는 형 검사를 수행하지 않는다. 이런 개념을 동적 타이핑이라고 부른다.

여기엔 단점도 존재한다. 정적 타이핑 시스템을 사용하는 경우 컴파일러와 여러가지 도구로 에러를 잡아낼 수 있지만, 동적 타이핑 시스템은 그런 도움을 받을 수 없다.

하지만 루비의 타이핑 시스템은 몇 가지 잠재적인 장점도 가지고 있는데, 클래스가 서로 동일한 방식으로 행동하기 위해 똑같은 부모로부터 상속할 필요가 없다는 점이다.

```ruby
>> i = 0
=> 0
>> a = ['100', 100.0]
=> ['100', 100.0]
>> while i < 2
>>   puts a[i].to_i
>>   i = i + 1
>> end
100
100
```

이 코드의 내용이 바로 덕 타이핑이라고 한다. 배열의 첫 번째 요소는 String 객체이고, 두 번째는 Float이다. 두 요소를 to_i라는 메서드를 통해 정수로 바꾼다. 보는 것처럼 덕 타이핑은 실제 주어진 자료형이 무엇인지 신경쓰지 않는다. 만약 그것이 오리처럼 걷고, 오리처럼 꽥꽥거리면 그것은 오리다. 여기서 꽥꽥에 해당하는 메서드가 to_i 이다.

덕 타이핑은 깔끔한 객체지향 설계를 할 때 대단히 중요하다. 객체지향의 설계 철학에서는 구체적인 구현이 아니라 인터페이스를 대상으로 코드를 작성하라는 말이 중요한 의미를 갖는다. 덕 타이핑을 사용하면, 불필요한 코드를 사용하지 않아도 이와 같은 철학을 따르기가 매우 쉽다. 어떤 객체가 push와 pop이라는 메서드를 가지고 있으면, 우리는 객체의 자료형과 관계없이 그것을 스택으로 취급할 수 있다. 그런 메서드가 없으면 스택이 아니다.

### 1일 차에 배운 내용

지금까지 아주 기초적인 내용을 살펴봤다. 루비는 인터프리트되는 객체지향 언어다. 거의 모든 것이 객체고, 메서드나 클래스 같은 객체의 일부에 접근하는 것이 쉽다. 루비는 덕 타이핑을 사용하고, 대부분의 경우 강한 타이핑 시스템을 사용하는 것처럼 행동한다. 루비는 NilClass와 String 같은 핵심적인 클래스 내부를 변경하는 것을 포함하여 거의 모든 것을 허용하는 자유주의 정신에 입각한 언어다.